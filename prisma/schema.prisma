// This is your Prisma schema file

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  CUSTOMER
  ADMIN
  MANAGER
  STAFF
  TAILOR    // Couturier - can view assigned orders and update production status
}

enum OrderStatus {
  PENDING
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  REFUNDED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum PaymentMethod {
  STRIPE
  WAVE
  ORANGE_MONEY
  MTN_MOBILE_MONEY
  CASH_ON_DELIVERY
  PAIEMENTPRO
  // Additional methods for manual invoice payments
  CASH
  BANK_TRANSFER
  CHECK
  OTHER
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   // Not unique alone - same person can have multiple roles with same email
  emailVerified DateTime?
  password      String?   // Only for ADMIN, MANAGER, STAFF
  phone         String    // Not unique alone - same person can have multiple roles
  phoneVerified DateTime?
  whatsappNumber String?  // May be different from phone
  image         String?
  role          UserRole  @default(CUSTOMER)

  // Customer profile fields
  dateOfBirth          DateTime?  // Date d'anniversaire
  howDidYouHearAboutUs String?    // Comment avez-vous connu CÈCHÉMOI?

  // Staff tracking - who created this customer
  createdByStaffId    String?
  createdByStaffName  String?

  // Geolocation data (captured during registration)
  ipAddress     String?
  city          String?
  country       String?
  countryCode   String?

  // Login tracking
  lastLoginAt      DateTime?
  lastLoginIp      String?
  lastLoginBrowser String?

  // User settings and metadata
  metadata      Json?     // For storing user preferences, notification settings, etc.

  // Two-Factor Authentication (for ADMIN, MANAGER, STAFF only)
  twoFactorEnabled      Boolean  @default(false)
  twoFactorPhone        String?  // Phone for 2FA OTP
  twoFactorBackupCodes  String?  @db.Text // JSON array of hashed backup codes

  // Password Reset (for ADMIN, MANAGER, STAFF only)
  passwordResetToken    String?   @unique
  passwordResetExpires  DateTime?

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  orders        Order[]
  addresses     Address[]
  cart          Cart?
  reviews       Review[]
  wishlist      WishlistItem[]
  otpCodes      OtpCode[]
  notifications Notification[]
  customerNotes CustomerNote[]
  abandonedCarts AbandonedCart[]
  loyaltyPoints LoyaltyPoints?
  invoices      Invoice[]
  invoicePayments InvoicePayment[] @relation("InvoicePaymentCreator")
  blogPosts     BlogPost[]
  deviceTokens  DeviceToken[]
  pushCampaigns PushCampaign[] @relation("CampaignCreator")
  pushLogs      PushNotificationLog[]
  measurements  CustomerMeasurement[]

  // Custom Orders (Sur-Mesure)
  customerCustomOrders  CustomOrder[]        @relation("CustomerCustomOrders") // Orders placed by this customer
  staffCustomOrders     CustomOrder[]        @relation("StaffCustomOrders")    // Orders created by this staff
  tailorAssignments     CustomOrderItem[]    @relation("TailorAssignments")    // Items assigned to this tailor
  receivedPayments      CustomOrderPayment[] @relation("PaymentReceiver")      // Payments received by this staff

  // Materials Management (Stock Atelier)
  materialUsages        MaterialMovement[]   @relation("TailorMaterialUsage")  // Materials used by this tailor
  materialMovements     MaterialMovement[]   @relation("StaffMaterialMovement") // Material movements recorded by this staff

  // Expenses Management (Dépenses)
  staffExpenses         Expense[]            @relation("StaffExpenses")         // Salary expenses for this staff member
  expensesCreated       Expense[]            @relation("ExpenseCreatedBy")      // Expenses recorded by this staff

  @@unique([phone, role]) // A person can have same phone for different roles (e.g. CUSTOMER + ADMIN)
  @@unique([email, role]) // A person can have same email for different roles
  @@index([phone])
  @@index([email])
  @@index([whatsappNumber])
  @@index([createdAt])
  @@index([role])
  @@index([createdByStaffId])
}

model CustomerNote {
  id          String   @id @default(cuid())
  customerId  String
  customer    User     @relation(fields: [customerId], references: [id], onDelete: Cascade)

  content     String
  noteType    String   // 'private' or 'shared'
  authorId    String?  // Admin who created the note
  authorName  String

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([customerId])
  @@index([createdAt])
}

model OtpCode {
  id        String   @id @default(cuid())
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  phone     String
  code      String
  purpose   String   // 'login', 'register', 'verify', 'reset'

  verified  Boolean  @default(false)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([phone])
  @@index([code])
  @@index([expiresAt])
}

enum NotificationType {
  ORDER_CONFIRMATION
  PAYMENT_CONFIRMATION
  ORDER_SHIPPED
  ORDER_DELIVERED
  WELCOME
  OTP_VERIFICATION
  PASSWORD_RESET
  ORDER_CANCELLED
}

enum NotificationChannel {
  WHATSAPP_360
  SMS
  WHATSAPP_CLOUD
  WHATSAPP
  EMAIL
  PUSH  // Mobile push notifications (FCM)
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
  DELIVERED
}

model Notification {
  id          String             @id @default(cuid())
  userId      String?
  user        User?              @relation(fields: [userId], references: [id], onDelete: SetNull)

  type        NotificationType
  channel     NotificationChannel
  status      NotificationStatus @default(PENDING)

  recipient   String             // Phone number or WhatsApp number
  message     String
  mediaUrl    String?            // For PDFs, images, etc.
  read        Boolean            @default(false) // User has read the notification

  // API Response tracking
  externalId  String?            // ID from the messaging service
  errorMessage String?
  sentAt      DateTime?
  deliveredAt DateTime?

  // Metadata
  metadata    Json?              // Additional data (order ID, etc.)

  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  @@index([userId])
  @@index([status])
  @@index([channel])
  @@index([type])
  @@index([createdAt])
}

model Category {
  id          String    @id @default(cuid())
  name        String
  slug        String    @unique
  description String?
  image       String?
  parentId    String?
  parent      Category? @relation("CategoryToCategory", fields: [parentId], references: [id], onDelete: SetNull)
  children    Category[] @relation("CategoryToCategory")
  products    Product[] @relation("ProductPrimaryCategory") // Primary category (backward compatible)
  productCategories ProductCategory[] // Many-to-many relationship
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([slug])
  @@index([parentId])
}

// Join table for Product-Category many-to-many relationship
model ProductCategory {
  id          String   @id @default(cuid())
  productId   String
  product     Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  categoryId  String
  category    Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())

  @@unique([productId, categoryId])
  @@index([productId])
  @@index([categoryId])
}

model Product {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?  @db.Text // Legacy field, kept for backward compatibility
  shortDescription String? @db.Text // 2-3 lines summary for product listings
  longDescription  String? @db.Text // Full HTML content from rich text editor
  price       Float
  salePrice   Float?
  sku         String   @unique
  stock       Int      @default(0)
  images      String[]
  featured    Boolean  @default(false)
  published   Boolean  @default(true)

  // Product type flag
  isWine      Boolean  @default(true) // true for wine products, false for accessories/other

  // Wine specific fields (only relevant when isWine = true)
  vintage     String?
  region      String?
  country     String?
  grapeVariety String?
  alcoholContent Float?
  volume      String?  // e.g., "750ml"
  wineType    String?  // Rouge, Blanc, Rosé, Effervescent, etc.

  // Product metadata
  weight      Float?   // in kg
  dimensions  String?  // e.g., "30x20x10cm"
  tags        String[] // Product tags

  // Inventory management
  lowStockThreshold Int   @default(10) // Alert when stock falls below this

  // SEO
  metaTitle       String?
  metaDescription String?

  // Marketing - Cross-sell and Up-sell
  relatedProducts String[] // Product IDs for cross-sell
  upsellProducts  String[] // Product IDs for up-sell

  // Tax
  taxClassId  String?
  taxClass    TaxClass? @relation("ProductTaxClass", fields: [taxClassId], references: [id])

  // Primary category (backward compatible - required)
  categoryId  String
  category    Category @relation("ProductPrimaryCategory", fields: [categoryId], references: [id])

  // Additional categories (many-to-many)
  productCategories ProductCategory[]

  variations  ProductVariation[]
  attributes  ProductAttribute[]
  stockMovements StockMovement[]
  orderItems  OrderItem[]
  cartItems   CartItem[]
  reviews     Review[]
  wishlistItems WishlistItem[]
  bundleItems ProductBundleItem[]
  invoiceItems InvoiceItem[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([slug])
  @@index([categoryId])
  @@index([published])
  @@index([featured])
  @@index([sku])
  @@index([taxClassId])
}

model ProductVariation {
  id          String   @id @default(cuid())
  productId   String
  product     Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  name        String   // e.g., "750ml", "1L", "Gift Box"
  sku         String   @unique
  price       Float
  salePrice   Float?
  stock       Int      @default(0)

  // Variation-specific attributes
  attributes  Json?    // e.g., {"size": "750ml", "vintage": "2018"}

  enabled     Boolean  @default(true)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([productId])
  @@index([sku])
}

model ProductAttribute {
  id          String   @id @default(cuid())
  productId   String
  product     Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  name        String   // e.g., "Couleur", "Taille"
  value       String   // e.g., "Rouge", "750ml"

  createdAt   DateTime @default(now())

  @@index([productId])
  @@index([name])
}

model StockMovement {
  id          String   @id @default(cuid())
  productId   String
  product     Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  type        String   // 'purchase', 'sale', 'adjustment', 'return', 'damaged'
  quantity    Int      // Positive for increase, negative for decrease
  previousStock Int    // Stock before movement
  newStock    Int      // Stock after movement

  reference   String?  // Order number, purchase order, etc.
  reason      String?  // Reason for adjustment
  notes       String?

  performedBy String?  // User ID who made the change
  performedByName String? // User name

  createdAt   DateTime @default(now())

  @@index([productId])
  @@index([type])
  @@index([createdAt])
}

model Cart {
  id        String     @id @default(cuid())
  userId    String     @unique
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  items     CartItem[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
}

model CartItem {
  id        String   @id @default(cuid())
  cartId    String
  cart      Cart     @relation(fields: [cartId], references: [id], onDelete: Cascade)
  productId String
  product   Product  @relation(fields: [productId], references: [id])
  quantity  Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([cartId, productId])
  @@index([cartId])
  @@index([productId])
}

model Order {
  id              String        @id @default(cuid())
  orderNumber     String        @unique
  userId          String
  user            User          @relation(fields: [userId], references: [id])

  status          OrderStatus   @default(PENDING)
  paymentStatus   PaymentStatus @default(PENDING)
  paymentMethod   PaymentMethod

  subtotal        Float
  tax             Float         @default(0)
  shippingCost    Float         @default(0)
  discount        Float         @default(0)
  total           Float

  // Payment tracking
  paymentReference String?      // PaiementPro transaction reference
  paymentSessionId String?      // PaiementPro session ID

  // Coupon tracking
  couponId        String?
  coupon          Coupon?       @relation(fields: [couponId], references: [id])
  couponCode      String?       // Store the code used

  // Shipping tracking
  shippingMethodId String?
  shippingMethod   ShippingMethod? @relation(fields: [shippingMethodId], references: [id])

  shippingAddressId String
  shippingAddress   Address      @relation(fields: [shippingAddressId], references: [id])

  items           OrderItem[]
  orderNotes      OrderNote[]
  refunds         Refund[]
  payment         Payment?
  invoice         Invoice?
  scheduledNotifications ScheduledNotification[]

  notes           String?
  trackingNumber  String?

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([userId])
  @@index([orderNumber])
  @@index([status])
  @@index([createdAt])
  @@index([couponId])
  @@index([shippingMethodId])
  @@index([paymentReference])
}

model OrderNote {
  id        String   @id @default(cuid())
  orderId   String
  order     Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)

  content   String
  noteType  String   // 'private' or 'customer'
  authorId  String?
  authorName String  // Could be system or admin name

  createdAt DateTime @default(now())

  @@index([orderId])
  @@index([createdAt])
}

model Refund {
  id          String   @id @default(cuid())
  orderId     String
  order       Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)

  amount      Float
  reason      String?
  refundType  String   // 'full' or 'partial'

  processedBy String?  // Admin user ID
  status      String   @default("pending") // pending, processed, failed

  createdAt   DateTime @default(now())
  processedAt DateTime?

  @@index([orderId])
  @@index([createdAt])
}

enum InvoiceStatus {
  DRAFT
  SENT
  PARTIAL    // Partially paid (has deposits/installments)
  PAID
  OVERDUE
  CANCELLED
  REFUNDED
}

enum InvoicePaymentType {
  DEPOSIT       // Avance (premier paiement)
  INSTALLMENT   // Acompte (paiement intermédiaire)
  FINAL         // Solde (paiement final)
}

model Invoice {
  id              String        @id @default(cuid())
  invoiceNumber   String        @unique

  // Order relation - OPTIONAL (for standalone invoices)
  orderId         String?       @unique
  order           Order?        @relation(fields: [orderId], references: [id], onDelete: SetNull)

  // Custom Order relation - OPTIONAL (for custom orders/sur-mesure)
  customOrderId   String?       @unique
  customOrder     CustomOrder?  @relation(fields: [customOrderId], references: [id], onDelete: SetNull)

  // Customer info (required even for standalone invoices)
  customerName    String
  customerEmail   String?
  customerPhone   String?
  customerAddress String?       @db.Text

  // Status
  status          InvoiceStatus @default(DRAFT)

  // Dates
  issueDate       DateTime      @default(now())
  dueDate         DateTime?
  paidDate        DateTime?

  // Amounts
  subtotal        Float
  tax             Float         @default(0)
  shippingCost    Float         @default(0)
  discount        Float         @default(0)
  total           Float
  amountPaid      Float         @default(0)  // Total amount paid so far (for installments)

  // Additional info
  notes           String?       @db.Text
  pdfUrl          String?       // Path to generated PDF
  currency        String        @default("CFA")

  // Email tracking
  sentAt          DateTime?
  sentTo          String?       // Email address

  // Audit
  createdById     String?
  createdBy       User?         @relation(fields: [createdById], references: [id], onDelete: SetNull)

  // Line items (for standalone invoices)
  items           InvoiceItem[]

  // Payment tracking (for installments/deposits)
  payments        InvoicePayment[]

  // Receipts generated for payments
  receipts        Receipt[]

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([invoiceNumber])
  @@index([status])
  @@index([orderId])
  @@index([customOrderId])
  @@index([createdById])
  @@index([issueDate])
  @@index([customerEmail])
}

model InvoiceItem {
  id          String   @id @default(cuid())
  invoiceId   String
  invoice     Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  // Item details (flexible for non-product items)
  description String
  quantity    Int
  unitPrice   Float
  total       Float

  // Optional product reference
  productId   String?
  product     Product? @relation(fields: [productId], references: [id], onDelete: SetNull)

  createdAt   DateTime @default(now())

  @@index([invoiceId])
  @@index([productId])
}

// Invoice Payment Tracking (for installments/deposits/partial payments)
model InvoicePayment {
  id              String        @id @default(cuid())
  invoiceId       String
  invoice         Invoice       @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  // Payment details
  amount          Float         // Amount of this payment
  paymentMethod   PaymentMethod // Payment method used
  paymentType     InvoicePaymentType @default(INSTALLMENT) // Type de paiement (Avance/Acompte/Solde)
  reference       String?       // Transaction reference / receipt number
  paidAt          DateTime      @default(now()) // When this payment was made

  // Additional info
  notes           String?       @db.Text

  // Provider info (if paid online)
  provider        String?       // PAIEMENTPRO, etc.
  providerRef     String?       // Provider transaction reference

  // Audit
  createdById     String?
  createdBy       User?         @relation("InvoicePaymentCreator", fields: [createdById], references: [id], onDelete: SetNull)

  // Receipt relation
  receipt         Receipt?

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([invoiceId])
  @@index([paidAt])
  @@index([paymentMethod])
}

model OrderItem {
  id        String   @id @default(cuid())
  orderId   String
  order     Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId String
  product   Product  @relation(fields: [productId], references: [id])
  quantity  Int
  price     Float
  total     Float
  createdAt DateTime @default(now())

  @@index([orderId])
  @@index([productId])
}

model Address {
  id           String   @id @default(cuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  fullName     String
  phone        String

  // African/Ivorian address format
  rue          String?  // Rue (street) - optional
  quartier     String?  // Quartier (neighborhood) - important in CI
  cite         String?  // Cité (area/district) - important in CI
  city         String   // Ville
  description  String?  @db.Text // Directions textuelles (ex: "à partir de la pharmacie Lagunes, tourner à gauche")

  // Geolocation (GPS coordinates)
  latitude     Float?   // Latitude GPS
  longitude    Float?   // Longitude GPS
  geoAccuracy  Float?   // Accuracy in meters
  geoSource    String?  // 'browser', 'mobile', 'manual'

  // Legacy fields for backward compatibility
  addressLine1 String   // Can store combined address
  addressLine2 String?  // Additional info
  state        String?  // Region/State
  zipCode      String?  // Postal code (rarely used in Africa)
  country      String   @default("Côte d'Ivoire")

  isDefault    Boolean  @default(false)

  orders       Order[]

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([userId])
  @@index([city])
  @@index([quartier])
  @@index([latitude, longitude])
}

model Review {
  id        String   @id @default(cuid())
  productId String
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  rating    Int      // 1-5
  title     String?
  comment   String?

  verified  Boolean  @default(false) // Verified purchase
  published Boolean  @default(true)

  // Admin reply
  adminReply String?
  repliedAt  DateTime?
  repliedBy  String?  // Admin user ID

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([productId])
  @@index([userId])
  @@index([published])
  @@unique([productId, userId])
}

model WishlistItem {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  productId String
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([userId, productId])
  @@index([userId])
  @@index([productId])
}

// Blog System Models
model BlogCategory {
  id          String     @id @default(cuid())
  name        String
  slug        String     @unique
  description String?
  image       String?
  color       String?    // For UI badge color
  parentId    String?
  parent      BlogCategory? @relation("BlogCategoryToCategory", fields: [parentId], references: [id], onDelete: SetNull)
  children    BlogCategory[] @relation("BlogCategoryToCategory")
  posts       BlogPost[]

  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@index([slug])
  @@index([parentId])
}

model BlogTag {
  id          String     @id @default(cuid())
  name        String
  slug        String     @unique
  description String?
  color       String?    // For UI badge color
  posts       BlogPostTag[]

  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@index([slug])
}

model BlogPost {
  id          String   @id @default(cuid())
  title       String
  slug        String   @unique
  excerpt     String?  @db.Text
  content     String   @db.Text
  image       String?

  // Publishing
  published   Boolean  @default(false)
  featured    Boolean  @default(false)
  publishedAt DateTime?

  // Author
  authorId    String
  author      User     @relation(fields: [authorId], references: [id])
  authorName  String?  // Cached for display

  // Category (single primary category)
  categoryId  String?
  category    BlogCategory? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

  // Tags (many-to-many)
  tags        BlogPostTag[]

  // SEO
  metaTitle       String?
  metaDescription String?

  // Stats
  viewCount   Int      @default(0)
  readTime    Int?     // Estimated reading time in minutes

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([slug])
  @@index([published])
  @@index([categoryId])
  @@index([authorId])
  @@index([featured])
  @@index([publishedAt])
}

// Join table for BlogPost-BlogTag many-to-many relationship
model BlogPostTag {
  id        String   @id @default(cuid())
  postId    String
  post      BlogPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  tagId     String
  tag       BlogTag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([postId, tagId])
  @@index([postId])
  @@index([tagId])
}

model Coupon {
  id              String   @id @default(cuid())
  code            String   @unique
  description     String?

  // Discount type and value
  discountType    String   // 'percentage' or 'fixed'
  discountValue   Float    // Percentage (0-100) or fixed amount

  // Restrictions
  minimumOrderAmount Float? // Minimum order amount to use coupon
  maximumDiscount    Float? // Maximum discount for percentage coupons

  // Category restrictions
  allowedCategories String[] // Empty means all categories
  excludedCategories String[] // Specific categories to exclude

  // Product restrictions
  allowedProducts String[] // Product IDs, empty means all products
  excludedProducts String[] // Product IDs to exclude

  // Usage limits
  usageLimit      Int?     // Total number of times coupon can be used (null = unlimited)
  usageLimitPerUser Int?   // Times each user can use it (null = unlimited)
  usageCount      Int      @default(0) // Track total uses

  // Validity period
  startsAt        DateTime?
  expiresAt       DateTime?

  // Status
  active          Boolean  @default(true)

  // Relations
  orders          Order[]
  usages          CouponUsage[]

  // Admin tracking
  createdBy       String?  // Admin user ID
  createdByName   String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([code])
  @@index([active])
  @@index([expiresAt])
}

model CouponUsage {
  id          String   @id @default(cuid())
  couponId    String
  coupon      Coupon   @relation(fields: [couponId], references: [id], onDelete: Cascade)

  userId      String
  orderId     String   // Which order used this coupon

  discountAmount Float // How much discount was applied
  orderTotal     Float // Total order amount

  createdAt   DateTime @default(now())

  @@index([couponId])
  @@index([userId])
  @@index([orderId])
}

model ShippingZone {
  id          String   @id @default(cuid())
  name        String   // e.g., "Côte d'Ivoire", "France", "Sénégal"
  countries   String[] // List of countries in this zone
  enabled     Boolean  @default(true)
  isDefault   Boolean  @default(false) // Default zone (Ivory Coast)

  methods     ShippingMethod[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([enabled])
  @@index([isDefault])
}

model ShippingMethod {
  id          String   @id @default(cuid())
  zoneId      String
  zone        ShippingZone @relation(fields: [zoneId], references: [id], onDelete: Cascade)

  name        String   // e.g., "Livraison Standard", "Livraison Express"
  description String?
  enabled     Boolean  @default(true)

  // Pricing
  costType    String   // 'flat_rate', 'free', 'weight_based', 'price_based'
  cost        Float    @default(0)

  // Conditions for free shipping or weight/price calculations
  minOrderAmount Float?  // Free or discounted if order exceeds this
  weightRanges   Json?   // [{min: 0, max: 5, cost: 2000}, {min: 5, max: 10, cost: 3500}]
  priceRanges    Json?   // [{min: 0, max: 50000, cost: 2000}, {min: 50000, max: null, cost: 0}]

  // Delivery time estimate
  estimatedDays String?  // e.g., "2-3 jours", "24h"

  // Tax settings
  taxable     Boolean  @default(false) // Whether shipping cost is taxable

  orders      Order[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([zoneId])
  @@index([enabled])
}

model TaxRate {
  id          String   @id @default(cuid())
  country     String   // e.g., "Côte d'Ivoire", "France"
  state       String?  // Optional state/region
  rate        Float    // Tax rate as percentage (e.g., 18 for 18%)
  name        String   // e.g., "VAT", "TVA", "Sales Tax"
  enabled     Boolean  @default(true)
  isDefault   Boolean  @default(false) // Default tax rate

  // Tax application
  applyToShipping Boolean @default(false)
  priority    Int      @default(1) // For multiple tax rates, lower number = higher priority

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([country])
  @@index([enabled])
  @@index([isDefault])
}

model TaxClass {
  id          String   @id @default(cuid())
  name        String   @unique // e.g., "Standard", "Reduced", "Zero-rated", "Exempt"
  description String?
  rate        Float?   // Override rate for this class (optional)
  enabled     Boolean  @default(true)

  products    Product[] @relation("ProductTaxClass")

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([enabled])
}

model TaxExemption {
  id          String   @id @default(cuid())
  userId      String   @unique
  reason      String   // Reason for exemption
  certificate String?  // Certificate number if applicable
  validUntil  DateTime? // Expiration date
  enabled     Boolean  @default(true)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([enabled])
}

model Settings {
  id                String   @id @default(cuid())
  siteName          String   @default("Cave Express")
  siteDescription   String?
  siteUrl           String?
  contactEmail      String?
  contactPhone      String?
  address           String?
  city              String?
  state             String?
  zipCode           String?
  country           String   @default("Côte d'Ivoire")

  // Tax & Currency
  currency          String   @default("XOF") // West African CFA franc
  currencySymbol    String   @default("CFA")
  currencyPosition  String   @default("before") // before, after
  thousandSeparator String   @default(",")
  decimalSeparator  String   @default(".")
  decimals          Int      @default(0)
  taxRate           Float    @default(18.0) // Default 18% VAT for Côte d'Ivoire
  pricesIncludeTax  Boolean  @default(false) // Whether displayed prices include tax
  calculateTax      Boolean  @default(true)  // Enable/disable tax calculation
  eurToXofRate      Float    @default(680.0) // Fixed exchange rate: 1 EUR = X XOF

  // Shipping
  freeShippingThreshold Float @default(0)
  flatShippingRate      Float @default(0)
  shippingCalculation   String @default("per_order") // per_order, per_item

  // Product Settings
  shopPageDisplay   String   @default("grid") // grid, list
  productsPerPage   Int      @default(12)
  defaultSorting    String   @default("date_desc") // date_desc, date_asc, price_asc, price_desc, name_asc, name_desc, popularity
  stockDisplayFormat String  @default("quantity") // quantity, in_stock_out_stock, hide
  lowStockThreshold  Int     @default(5)
  outOfStockVisibility Boolean @default(true) // Show out of stock products
  enableReviews      Boolean @default(true)
  reviewsRequirePurchase Boolean @default(false) // Only verified purchases can review

  // Cart & Checkout
  enableGuestCheckout Boolean @default(true)
  cartPageEnabled    Boolean  @default(true)
  enableCoupons      Boolean  @default(true)
  calculateShipping  Boolean  @default(true)
  requirePhone       Boolean  @default(true)
  requireEmail       Boolean  @default(false)

  // Account & Privacy
  enableRegistration Boolean  @default(true)
  accountCreation    String   @default("optional") // optional, required, disabled
  privacyPolicyPage  String?
  termsPage          String?
  enableNewsletterSignup Boolean @default(true)

  // Email Settings
  emailFromName      String   @default("Cave Express")
  emailFromAddress   String?
  enableOrderEmails  Boolean  @default(true)
  enableWelcomeEmail Boolean  @default(true)
  enableLowStockEmail Boolean @default(true)
  lowStockEmailRecipient String?

  // Permalinks
  productSlugPrefix  String?  // e.g., "produit", "wine"
  categorySlugPrefix String?  // e.g., "categorie"

  // API & Advanced
  enableAPI          Boolean  @default(false)
  apiKey             String?  @unique
  enableWebhooks     Boolean  @default(false)
  webhookUrl         String?

  // Social Media
  facebookUrl       String?
  instagramUrl      String?
  twitterUrl        String?
  whatsappNumber    String?

  // Maintenance
  maintenanceMode   Boolean  @default(false)
  maintenanceMessage String?

  updatedAt         DateTime @updatedAt
}

// Marketing Models

model ProductBundle {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  
  // Pricing
  regularPrice Float   // Sum of individual product prices
  bundlePrice  Float   // Discounted bundle price
  discount     Float   // Discount percentage
  
  enabled     Boolean  @default(true)
  featured    Boolean  @default(false)
  
  items       ProductBundleItem[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([slug])
  @@index([enabled])
}

model ProductBundleItem {
  id        String   @id @default(cuid())
  bundleId  String
  bundle    ProductBundle @relation(fields: [bundleId], references: [id], onDelete: Cascade)
  
  productId String
  product   Product  @relation(fields: [productId], references: [id])
  
  quantity  Int      @default(1)
  
  createdAt DateTime @default(now())
  
  @@index([bundleId])
  @@index([productId])
}

model AbandonedCart {
  id          String   @id @default(cuid())
  userId      String?
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  // Guest info if no user
  guestEmail  String?
  guestPhone  String?
  
  // Cart data
  items       Json     // Cart items snapshot
  subtotal    Float
  
  // Recovery
  recovered   Boolean  @default(false)
  recoveredAt DateTime?
  emailSent   Boolean  @default(false)
  emailSentAt DateTime?
  
  expiresAt   DateTime // When to stop tracking
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([userId])
  @@index([recovered])
  @@index([emailSent])
  @@index([expiresAt])
}

model LoyaltyPoints {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  points      Int      @default(0)
  totalEarned Int      @default(0) // Lifetime points earned
  totalSpent  Int      @default(0) // Lifetime points spent
  
  tier        String   @default("bronze") // bronze, silver, gold, platinum
  
  transactions LoyaltyTransaction[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([userId])
  @@index([tier])
}

model LoyaltyTransaction {
  id          String   @id @default(cuid())
  loyaltyId   String
  loyalty     LoyaltyPoints @relation(fields: [loyaltyId], references: [id], onDelete: Cascade)

  type        String   // earn, spend, expire, adjustment
  points      Int      // Positive for earn, negative for spend

  reason      String   // "Purchase #12345", "Redeemed for discount", etc.
  orderId     String?  // Related order if applicable

  balance     Int      // Balance after transaction

  createdAt   DateTime @default(now())

  @@index([loyaltyId])
  @@index([createdAt])
}

// Advanced Reporting
model SavedReport {
  id          String   @id @default(cuid())
  name        String
  description String?

  // Report configuration
  reportType  String   // sales, customers, products, inventory, tax, custom
  dateRange   String   // today, week, month, year, custom, all_time
  startDate   DateTime?
  endDate     DateTime?

  // Filters (stored as JSON)
  filters     Json?    // { status: ['completed'], category: 'electronics', etc. }

  // Columns to include
  columns     String[] // ['product', 'revenue', 'quantity', etc.]

  // Grouping and sorting
  groupBy     String?  // 'product', 'category', 'customer', 'date', etc.
  sortBy      String?  // 'revenue', 'quantity', 'date', etc.
  sortOrder   String   @default("desc") // asc, desc

  // User who created
  createdBy   String

  // Scheduling
  schedules   ReportSchedule[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([createdBy])
  @@index([reportType])
}

model ReportSchedule {
  id          String   @id @default(cuid())
  reportId    String
  report      SavedReport @relation(fields: [reportId], references: [id], onDelete: Cascade)

  // Schedule config
  frequency   String   // daily, weekly, monthly
  dayOfWeek   Int?     // 0-6 for weekly (0 = Sunday)
  dayOfMonth  Int?     // 1-31 for monthly
  time        String   // HH:mm format

  // Delivery
  recipients  String[] // Email addresses
  format      String   @default("pdf") // pdf, csv, xlsx

  enabled     Boolean  @default(true)
  lastRun     DateTime?
  nextRun     DateTime?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([reportId])
  @@index([enabled])
  @@index([nextRun])
}

// Payment Tracking Model
model Payment {
  id                String   @id @default(cuid())
  orderId           String   @unique
  order             Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)

  // Payment provider details
  provider          String   // 'PAIEMENTPRO', 'STRIPE', etc.
  reference         String   @unique // Transaction reference from provider
  sessionId         String?  // Session ID for redirect-based payments

  // Amount tracking
  amount            Float    // Amount in XOF (or other currency)
  currency          String   @default("XOF")

  // Customer information
  customerEmail     String
  customerFirstName String
  customerLastName  String
  customerPhone     String

  // Payment channel (for PaiementPro)
  channel           String?  // OMCIV2, MOMOCI, FLOOZ, WAVECI, CARD, etc.

  // Payment status
  status            PaymentStatus @default(PENDING)

  // Provider response data
  providerResponse  Json?    // Store full provider response
  errorMessage      String?

  // Transaction tracking
  transactionDate   DateTime?
  paymentId         String?  // Provider's payment ID (e.g., CI2023013113165473)

  // Metadata
  description       String?
  returnContext     Json?    // Custom data passed to provider

  // Webhooks tracking
  webhookReceived   Boolean  @default(false)
  webhookReceivedAt DateTime?

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([reference])
  @@index([status])
  @@index([provider])
  @@index([orderId])
  @@index([customerEmail])
  @@index([createdAt])
}

// Notification Templates System
enum NotificationTrigger {
  ORDER_PLACED
  ORDER_PROCESSING
  ORDER_SHIPPED
  ORDER_DELIVERED
  ORDER_CANCELLED
  ORDER_REFUNDED
  PAYMENT_RECEIVED
  PAYMENT_FAILED
  CUSTOMER_NOTE
  NEW_ACCOUNT
  PASSWORD_RESET
  LOYALTY_POINTS_EARNED
  ABANDONED_CART
  BACK_IN_STOCK
  NEW_ORDER_ADMIN
  PAYMENT_RECEIVED_ADMIN
  LOW_STOCK_ADMIN
  OUT_OF_STOCK_ADMIN
  NEW_CUSTOMER_ADMIN
  NEW_REVIEW_ADMIN
  DAILY_REPORT_ADMIN
  // New notifications
  INVOICE_CREATED       // Invoice with link sent after order placement
  INVOICE_PAID          // Invoice marked as paid notification
  REVIEW_REQUEST        // Ask for Trustpilot review after shipping
  PAYMENT_REMINDER_1    // 1 day after unpaid order
  PAYMENT_REMINDER_2    // 3 days after unpaid order
  PAYMENT_REMINDER_3    // 5 days after unpaid order
  // Standalone payments (/payer/ flow)
  STANDALONE_PAYMENT_RECEIVED
  STANDALONE_PAYMENT_FAILED
  // Appointment notifications
  APPOINTMENT_BOOKED           // Customer: Confirmation after booking
  APPOINTMENT_CONFIRMED        // Customer: Admin confirms appointment
  APPOINTMENT_REMINDER         // Customer: Reminder before appointment
  APPOINTMENT_CANCELLED        // Customer: Appointment cancelled
  APPOINTMENT_BOOKED_ADMIN     // Admin: New appointment notification
}

model NotificationTemplate {
  id          String              @id @default(cuid())

  // Template identification
  trigger     NotificationTrigger
  channel     NotificationChannel
  name        String              // e.g., "Order Placed - SMS"
  description String?

  // Template content
  subject     String?             // For emails
  content     String              // Template with variables

  // Push notification content (short versions for mobile)
  pushTitle   String?             // Push notification title (max 65 chars)
  pushBody    String?             // Push notification body (max 240 chars)

  // Recipient
  recipientType String            // 'customer' or 'admin'

  // Settings
  enabled     Boolean             @default(true)

  // Admin settings
  adminPhone  String?             // Admin phone for admin notifications

  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  @@unique([trigger, channel]) // One template per trigger/channel combination
  @@index([trigger])
  @@index([channel])
  @@index([enabled])
}

model NotificationSettings {
  id                    String   @id @default(cuid())

  // Admin phones for notifications
  adminPhones           String[] // Array of admin phone numbers
  adminWhatsApp         String?  // Admin WhatsApp number
  adminEmails           String[] // Array of admin emails

  // SMS Provider settings
  smsProvider           String   @default("SMSING") // SMSING, TWILIO, etc.
  smsApiKey             String?
  smsSenderId           String?

  // WhatsApp Provider settings
  whatsappProvider      String   @default("360") // 360, CLOUD, etc.
  whatsappApiKey        String?
  whatsappPhoneId       String?

  // Email Provider settings
  emailProvider         String   @default("RESEND")
  emailApiKey           String?
  emailFromAddress      String?
  emailFromName         String?

  // Global notification toggles
  smsEnabled            Boolean  @default(true)
  whatsappEnabled       Boolean  @default(true)
  emailEnabled          Boolean  @default(false)
  pushEnabled           Boolean  @default(true)

  // Failover settings
  failoverEnabled       Boolean  @default(true)
  failoverOrder         String[] @default(["WHATSAPP", "SMS"]) // Order of failover

  // Push notification settings (Firebase)
  firebaseProjectId     String?
  firebaseClientEmail   String?
  firebasePrivateKey    String? @db.Text

  // Testing
  testMode              Boolean  @default(false)
  testPhoneNumber       String?

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@unique([id]) // Ensure only one settings record
}

// Store notification history for analytics
model NotificationLog {
  id          String              @id @default(cuid())

  // Template used
  trigger     NotificationTrigger
  channel     NotificationChannel

  // Recipient
  recipientPhone  String?
  recipientEmail  String?
  recipientName   String?

  // Content
  content     String

  // Status
  status      String              // 'sent', 'failed', 'pending'
  errorMessage String?

  // Provider response
  providerId  String?             // ID from SMS/WhatsApp provider
  providerResponse Json?

  // Related entities
  orderId     String?
  userId      String?

  // Cost tracking
  cost        Float?              // Cost in credits/money

  sentAt      DateTime?
  createdAt   DateTime            @default(now())

  @@index([trigger])
  @@index([channel])
  @@index([status])
  @@index([orderId])
  @@index([userId])
  @@index([createdAt])
}

// Scheduled Notifications (for payment reminders, follow-ups, etc.)
model ScheduledNotification {
  id          String              @id @default(cuid())

  // Type of scheduled notification
  trigger     NotificationTrigger

  // Related entities
  orderId     String
  order       Order               @relation(fields: [orderId], references: [id], onDelete: Cascade)
  userId      String?

  // Scheduling
  scheduledFor DateTime           // When to send the notification
  reminderNumber Int              @default(1) // 1, 2, or 3 for payment reminders

  // Status
  status      String              @default("pending") // 'pending', 'sent', 'cancelled', 'failed'
  sentAt      DateTime?
  cancelledAt DateTime?

  // Error tracking
  errorMessage String?
  attempts    Int                 @default(0)

  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  @@index([status])
  @@index([scheduledFor])
  @@index([orderId])
  @@index([trigger])
}

// Payment Follow-up Settings (admin configurable)
model PaymentFollowUpSettings {
  id                String   @id @default("default")

  // Enable/disable follow-ups
  enabled           Boolean  @default(true)

  // Reminder delays in hours
  reminder1Delay    Int      @default(24)   // 1 day = 24 hours
  reminder2Delay    Int      @default(72)   // 3 days = 72 hours
  reminder3Delay    Int      @default(120)  // 5 days = 120 hours

  // Enable individual reminders
  reminder1Enabled  Boolean  @default(true)
  reminder2Enabled  Boolean  @default(true)
  reminder3Enabled  Boolean  @default(true)

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

// Marketing campaigns (bulk SMS/WhatsApp messaging)
model Campaign {
  id          String   @id @default(cuid())
  name        String   // Campaign name
  channel     NotificationChannel  // SMS, WHATSAPP, WHATSAPP_CLOUD

  // Content
  message     String   @db.Text
  mediaUrl    String?  // For WhatsApp images/files
  template    String?  // For WhatsApp Cloud (template name)

  // Targeting
  targetType  String   // 'all', 'custom', 'segment'
  customNumbers String? @db.Text  // JSON array of phone numbers
  segmentFilter Json?   // Filter criteria for customer segment

  // Statistics
  totalRecipients Int    @default(0)
  sentCount       Int    @default(0)
  failedCount     Int    @default(0)

  // Status
  status      String   @default("draft") // draft, scheduled, sending, sent, failed
  scheduledAt DateTime?
  startedAt   DateTime?
  completedAt DateTime?

  // Created by
  createdBy   String
  createdByName String

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  logs        CampaignLog[]

  @@index([channel])
  @@index([status])
  @@index([createdBy])
  @@index([createdAt])
}

// Individual campaign message logs
model CampaignLog {
  id          String   @id @default(cuid())

  campaignId  String
  campaign    Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  // Recipient
  phone       String
  customerName String?
  userId      String?  // If sent to registered customer

  // Content sent
  message     String   @db.Text
  mediaUrl    String?

  // Status
  status      String   // sent, failed, pending
  errorMessage String?
  providerId  String?  // ID from SMS/WhatsApp provider
  providerResponse Json?

  // Cost tracking
  cost        Float?

  sentAt      DateTime?
  createdAt   DateTime @default(now())

  @@index([campaignId])
  @@index([phone])
  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

// ========================================
// STANDALONE PAYMENTS (for /payer/ flow)
// ========================================

model StandalonePayment {
  id              String        @id @default(cuid())
  reference       String        @unique
  amount          Int           // Amount in XOF
  customerName    String
  customerPhone   String
  channel         String?       // OMCIV2, MOMOCI, FLOOZ, WAVECI, CARD, PAYPAL

  // Payment status
  status          PaymentStatus @default(PENDING)

  // PaiementPro data
  sessionId       String?
  paymentId       String?       // Provider's payment ID
  providerResponse Json?
  errorMessage    String?

  // Timestamps
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  paidAt          DateTime?

  // Webhook tracking
  webhookReceived   Boolean     @default(false)
  webhookReceivedAt DateTime?

  // Notification tracking
  notificationSent  Boolean     @default(false)
  notificationSentAt DateTime?

  @@index([reference])
  @@index([status])
  @@index([customerPhone])
  @@index([createdAt])
}

// ========================================
// PUSH NOTIFICATIONS (FCM)
// ========================================

enum DevicePlatform {
  IOS
  ANDROID
  WEB
}

enum PushTargetType {
  ALL_USERS
  SPECIFIC_USERS
  BY_TIER
  BY_LOCATION
}

enum PushCampaignStatus {
  DRAFT
  SCHEDULED
  SENDING
  SENT
  FAILED
}

enum PushDeliveryStatus {
  PENDING
  SENT
  DELIVERED
  OPENED
  CLICKED
  FAILED
}

// Store FCM tokens for mobile devices
model DeviceToken {
  id            String         @id @default(cuid())
  userId        String
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Device info
  token         String         @unique // FCM token
  platform      DevicePlatform // iOS, Android, Web
  deviceModel   String?
  osVersion     String?
  appVersion    String?

  // Metadata
  isActive      Boolean        @default(true)
  lastUsedAt    DateTime       @default(now())
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  @@index([userId])
  @@index([token])
  @@index([platform])
  @@index([isActive])
}

// Push notification campaigns (admin sends to users)
model PushCampaign {
  id               String             @id @default(cuid())

  // Campaign details
  name             String
  title            String             // Notification title (max 65 chars)
  body             String             // Notification body (max 240 chars)
  imageUrl         String?            // Rich notification image
  deepLink         String?            // Link to product/category/screen

  // Targeting
  targetType       PushTargetType
  targetUserIds    String[]           // Specific user IDs (if targetType = SPECIFIC_USERS)
  targetTier       String?            // If targetType = BY_TIER (BRONZE, SILVER, GOLD)
  targetCity       String?            // If targetType = BY_LOCATION

  // Scheduling
  status           PushCampaignStatus @default(DRAFT)
  scheduledFor     DateTime?          // null = send now
  sentAt           DateTime?

  // Stats
  totalSent        Int                @default(0)
  totalDelivered   Int                @default(0)
  totalOpened      Int                @default(0)
  totalClicked     Int                @default(0)

  // Audit
  createdBy        String
  creator          User               @relation("CampaignCreator", fields: [createdBy], references: [id])
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt

  // Relations
  logs             PushNotificationLog[]

  @@index([status])
  @@index([createdBy])
  @@index([createdAt])
}

// Individual push notification delivery logs
model PushNotificationLog {
  id            String             @id @default(cuid())

  // Campaign
  campaignId    String
  campaign      PushCampaign       @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  // Recipient
  userId        String
  user          User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  deviceToken   String

  // Delivery tracking
  status        PushDeliveryStatus @default(PENDING)
  sentAt        DateTime           @default(now())
  deliveredAt   DateTime?
  openedAt      DateTime?
  clickedAt     DateTime?

  // Error tracking
  error         String?

  @@index([campaignId])
  @@index([userId])
  @@index([status])
}

// ========================================
// CONSULTATION / APPOINTMENT SYSTEM
// ========================================

enum AppointmentStatus {
  PENDING       // Waiting for confirmation
  CONFIRMED     // Admin confirmed
  COMPLETED     // Done
  CANCELLED     // Cancelled by admin or customer
  NO_SHOW       // Customer didn't show up
}

enum AppointmentPaymentStatus {
  UNPAID        // Not paid yet
  PAID          // Paid (online or in-person)
  REFUNDED      // Refunded
  QUOTE_PENDING // Price to be determined (Sur devis)
}

// Types of consultations offered
model ConsultationType {
  id            String   @id @default(cuid())
  name          String   // e.g., "Analyse Morphologique", "Personal Shopping"
  slug          String   @unique
  description   String?  @db.Text

  // Pricing
  price         Int      @default(0) // Price in XOF (0 = Sur devis / Free)
  duration      Int      @default(60) // Duration in minutes

  // Features (shown on booking page)
  features      String[] // e.g., ["Analyse complète", "Rapport PDF", ...]

  // Appearance
  color         String?  // Hex color for UI
  icon          String?  // Icon name or emoji

  // Settings
  enabled       Boolean  @default(true)
  requiresPayment Boolean @default(true) // Must pay before confirmation

  // Order for display
  sortOrder     Int      @default(0)

  appointments  Appointment[]

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([enabled])
  @@index([sortOrder])
}

// Admin availability slots (recurring or specific dates)
model AdminAvailability {
  id            String   @id @default(cuid())

  // Day of week (0=Sunday, 1=Monday, ..., 6=Saturday) OR specific date
  dayOfWeek     Int?     // For recurring weekly slots
  specificDate  DateTime? // For specific date slots (overrides dayOfWeek)

  // Time slots
  startTime     String   // e.g., "09:00"
  endTime       String   // e.g., "18:00"

  // Slot configuration
  slotDuration  Int      @default(60) // Minutes per appointment
  breakBetween  Int      @default(15) // Break between appointments

  // Availability
  enabled       Boolean  @default(true)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([dayOfWeek])
  @@index([specificDate])
  @@index([enabled])
}

// Customer appointments
model Appointment {
  id            String   @id @default(cuid())
  reference     String   @unique // e.g., "RDV-2025-ABC123"

  // Type of consultation
  typeId        String
  type          ConsultationType @relation(fields: [typeId], references: [id])

  // Customer info (can be logged-in user or guest)
  userId        String?  // If registered user
  customerName  String
  customerPhone String
  customerEmail String?
  customerNotes String?  @db.Text // What customer wants to discuss

  // Scheduling
  date          DateTime // Date of appointment
  time          String   // e.g., "14:00"
  duration      Int      // Duration in minutes

  // Status
  status        AppointmentStatus @default(PENDING)
  paymentStatus AppointmentPaymentStatus @default(UNPAID)

  // Pricing
  price         Int      @default(0) // Price in XOF
  paidAmount    Int      @default(0) // Amount paid
  paymentMethod String?  // CASH, ORANGE_MONEY, MTN, WAVE, CARD, etc.
  paymentReference String? // Transaction reference

  // Admin notes (internal)
  adminNotes    String?  @db.Text

  // Reminders
  reminderSent  Boolean  @default(false)
  reminderSentAt DateTime?

  // Confirmation
  confirmedAt   DateTime?
  confirmedBy   String?  // Admin user ID

  // Cancellation
  cancelledAt   DateTime?
  cancelledBy   String?  // 'customer' or admin user ID
  cancelReason  String?

  // Completion
  completedAt   DateTime?
  completedBy   String?  // Admin user ID
  completionNotes String? @db.Text

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([reference])
  @@index([typeId])
  @@index([userId])
  @@index([customerPhone])
  @@index([date])
  @@index([status])
  @@index([paymentStatus])
  @@index([createdAt])
}

// ========================================
// CUSTOMER MEASUREMENTS (Body measurements for fashion)
// ========================================

model CustomerMeasurement {
  id              String   @id @default(cuid())
  customerId      String
  customer        User     @relation(fields: [customerId], references: [id], onDelete: Cascade)

  // Staff tracking - who took these measurements
  takenByStaffId    String?
  takenByStaffName  String?
  measurementDate   DateTime @default(now())

  // Measurement unit
  unit              String   @default("cm") // cm or inches

  // === 22 BODY MEASUREMENTS ===
  // All measurements are String to allow flexible input like "87-2" or "50 - 45"
  // Upper body (1-9)
  dos               String?  // 1. DOS (back)
  carrureDevant     String?  // 2. CARRURE DEVANT (front width)
  carrureDerriere   String?  // 3. CARRURE DERRIERE (back width)
  epaule            String?  // 4. EPAULE (shoulder)
  epauleManche      String?  // 5. EPAULE MANCHE (shoulder to sleeve)
  poitrine          String?  // 6. POITRINE (chest/bust)
  tourDeTaille      String?  // 7. TOUR DE TAILLE (waist)
  longueurDetaille  String?  // 8. LONGUEUR DE TAILLE
  bassin            String?  // 9. BASSIN (hip)

  // Arms (10-12)
  // 10. LONGUEUR DES MANCHES - 4 sub-fields
  longueurManchesCourtes      String?  // 10a. Manches courtes
  longueurManchesAvantCoudes  String?  // 10b. Avant les coudes
  longueurManchesNiveau34     String?  // 10c. Niveau 3/4
  longueurManchesLongues      String?  // 10d. Manches longues
  tourDeManche      String?  // 11. TOUR DE MANCHE (sleeve circumference)
  poignets          String?  // 12. POIGNETS (wrists)

  // Torso (13-17)
  pinces            String?  // 13. PINCES (darts)
  longueurTotale    String?  // 14. LONGUEUR TOTALE (total length)
  // 15. LONGUEUR DES ROBES - 6 sub-fields
  longueurRobesAvantGenoux    String?  // 15a. Avant les genoux
  longueurRobesNiveauGenoux   String?  // 15b. Au niveau des genoux
  longueurRobesApresGenoux    String?  // 15c. Apres les genoux (crayon)
  longueurRobesMiMollets      String?  // 15d. Mi-mollets
  longueurRobesChevilles      String?  // 15e. Niveau des chevilles
  longueurRobesTresLongue     String?  // 15f. Tres longue
  longueurTunique   String?  // 16. LONGUEUR TUNIQUE (tunic length)
  ceinture          String?  // 17. CEINTURE (belt/waist)

  // Lower body (18-22)
  longueurPantalon  String?  // 18. LONGUEUR PANTALON (pants length)
  frappe            String?  // 19. FRAPPE
  cuisse            String?  // 20. CUISSE (thigh)
  genoux            String?  // 21. GENOUX (knees)
  // 22. LONGUEUR JUPE - 6 sub-fields
  longueurJupeAvantGenoux     String?  // 22a. Avant les genoux
  longueurJupeNiveauGenoux    String?  // 22b. Au niveau des genoux
  longueurJupeApresGenoux     String?  // 22c. Apres les genoux (crayon)
  longueurJupeMiMollets       String?  // 22d. Mi-mollets
  longueurJupeChevilles       String?  // 22e. Niveau des chevilles
  longueurJupeTresLongue      String?  // 22f. Tres longue

  // DEPRECATED: Old JSON fields - will be removed after data migration
  longueurManches   String?  // @deprecated - use sub-fields above
  longueurRobes     String?  // @deprecated - use sub-fields above
  longueurJupe      String?  // @deprecated - use sub-fields above

  // Notes
  autresMesures     String?  @db.Text // AUTRES MESURES OU OBSERVATIONS

  // PDF Storage (S3)
  pdfUrl            String?  // Full S3 URL of the generated PDF
  pdfKey            String?  // S3 key for deletion/retrieval
  pdfGeneratedAt    DateTime? // When the PDF was last generated

  createdAt         DateTime @default(now())

  @@index([customerId])
  @@index([takenByStaffId])
  @@index([measurementDate])

  // Relation to custom orders using these measurements
  customOrders  CustomOrder[]
}

// ========================================
// MATERIALS MANAGEMENT (Stock Atelier)
// ========================================

model MaterialCategory {
  id          String     @id @default(cuid())
  name        String     @unique
  description String?
  isDefault   Boolean    @default(false)
  sortOrder   Int        @default(0)
  materials   Material[]
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@index([sortOrder])
}

model Material {
  id                String             @id @default(cuid())
  name              String
  sku               String?            @unique
  categoryId        String
  category          MaterialCategory   @relation(fields: [categoryId], references: [id])

  unit              String             // "mètre", "pièce", "bobine", "kg", "rouleau"
  unitPrice         Float              @default(0)
  stock             Float              @default(0)
  lowStockThreshold Float              @default(0)

  description       String?            @db.Text
  supplier          String?
  color             String?

  movements         MaterialMovement[]
  isActive          Boolean            @default(true)

  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  @@index([categoryId])
  @@index([isActive])
  @@index([stock])
}

enum MaterialMovementType {
  IN        // Entrée (achat, réception)
  OUT       // Sortie (utilisation)
  ADJUST    // Ajustement d'inventaire
  RETURN    // Retour (matériel non utilisé)
}

model MaterialMovement {
  id                String               @id @default(cuid())
  materialId        String
  material          Material             @relation(fields: [materialId], references: [id], onDelete: Cascade)

  type              MaterialMovementType
  quantity          Float
  unitPrice         Float
  totalCost         Float
  previousStock     Float
  newStock          Float

  // Pour les sorties (OUT) - couturier et commande
  tailorId          String?
  tailor            User?                @relation("TailorMaterialUsage", fields: [tailorId], references: [id], onDelete: SetNull)
  customOrderId     String?
  customOrder       CustomOrder?         @relation(fields: [customOrderId], references: [id], onDelete: SetNull)
  customOrderItemId String?

  // Traçabilité staff
  createdById       String?
  createdBy         User?                @relation("StaffMaterialMovement", fields: [createdById], references: [id], onDelete: SetNull)
  createdByName     String?

  notes             String?              @db.Text
  reference         String?              // N° bon de commande fournisseur

  createdAt         DateTime             @default(now())

  @@index([materialId])
  @@index([tailorId])
  @@index([customOrderId])
  @@index([createdById])
  @@index([createdAt])
  @@index([type])
}

// ========================================
// CUSTOM ORDERS (Commandes Sur-Mesure)
// ========================================

enum CustomOrderStatus {
  PENDING         // En attente
  IN_PRODUCTION   // En production
  FITTING         // Essayage prévu
  ALTERATIONS     // Retouches en cours
  READY           // Prêt
  DELIVERED       // Livré
  CANCELLED       // Annulé
}

enum CustomOrderPriority {
  NORMAL          // Standard (14 jours)
  URGENT          // Urgent (+50% prix)
  VIP             // Rush (+100% prix)
}

enum ItemProductionStatus {
  PENDING         // En attente
  CUTTING         // Coupe en cours
  SEWING          // Couture en cours
  FITTING         // Essayage
  ALTERATIONS     // Retouches
  FINISHING       // Finitions
  COMPLETED       // Terminé
  DELIVERED       // Livré
}

enum CustomPaymentType {
  DEPOSIT         // Avance initiale
  INSTALLMENT     // Paiement intermédiaire
  FINAL           // Solde final
}

model CustomOrder {
  id              String   @id @default(cuid())
  orderNumber     String   @unique  // Format: SM-2025-001

  // Client
  customerId      String
  customer        User     @relation("CustomerCustomOrders", fields: [customerId], references: [id], onDelete: Cascade)

  // Dates clés
  orderDate       DateTime @default(now())
  pickupDate      DateTime // Date retrait (défaut: +14 jours)
  customerDeadline DateTime? // Délai souhaité client

  // Financier (style Excel)
  totalCost       Float    @default(0) // Coût total tenues
  materialCost    Float    @default(0) // Coût matériel
  // Note: deposit et reliquat calculés via CustomOrderPayment

  // Statut global
  status          CustomOrderStatus @default(PENDING)
  priority        CustomOrderPriority @default(NORMAL)

  // Mensurations utilisées (optional - can use existing or create new)
  measurementId   String?
  measurement     CustomerMeasurement? @relation(fields: [measurementId], references: [id])

  // Staff qui a créé la commande
  createdById     String
  createdBy       User     @relation("StaffCustomOrders", fields: [createdById], references: [id])

  notes           String?  @db.Text

  // Relations
  items           CustomOrderItem[]
  payments        CustomOrderPayment[]
  timeline        CustomOrderTimeline[]
  attachments     CustomOrderAttachment[]

  // Invoice relation (auto-generated)
  invoice         Invoice?

  // Receipts for payments
  receipts        Receipt[]

  // Materials used for this order
  materialUsages  MaterialMovement[]

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([customerId])
  @@index([createdById])
  @@index([status])
  @@index([orderDate])
  @@index([pickupDate])
}

model CustomOrderItem {
  id              String   @id @default(cuid())
  customOrderId   String
  customOrder     CustomOrder @relation(fields: [customOrderId], references: [id], onDelete: Cascade)

  // Description
  garmentType     String   // "Robe de soirée", "Boubou", "Ensemble tunique", etc.
  customType      String?  // Si garmentType = "Autre", saisie personnalisée
  description     String?  @db.Text // Détails spécifiques (couleur, tissu, etc.)
  quantity        Int      @default(1)
  unitPrice       Float    @default(0)

  // Production
  status          ItemProductionStatus @default(PENDING)
  tailorId        String?  // Couturier assigné
  tailor          User?    @relation("TailorAssignments", fields: [tailorId], references: [id])

  // Temps
  estimatedHours  Float?   // Heures estimées
  actualHours     Float?   // Heures réelles (cumulées)

  // Dates production
  startedAt       DateTime?
  completedAt     DateTime?

  notes           String?  @db.Text

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([customOrderId])
  @@index([tailorId])
  @@index([status])
}

model CustomOrderPayment {
  id              String   @id @default(cuid())
  customOrderId   String
  customOrder     CustomOrder @relation(fields: [customOrderId], references: [id], onDelete: Cascade)

  amount          Float
  paymentType     CustomPaymentType @default(DEPOSIT)
  paymentMethod   String?  // CASH, WAVE, ORANGE_MONEY, etc.

  // Staff qui a reçu le paiement
  receivedById    String?
  receivedBy      User?    @relation("PaymentReceiver", fields: [receivedById], references: [id])

  paidAt          DateTime @default(now())
  notes           String?

  // Receipt relation
  receipt         Receipt?

  // Synced invoice payment
  invoicePaymentId String? @unique

  @@index([customOrderId])
  @@index([paidAt])
}

model CustomOrderTimeline {
  id              String   @id @default(cuid())
  customOrderId   String
  customOrder     CustomOrder @relation(fields: [customOrderId], references: [id], onDelete: Cascade)

  // Event info
  event           String   // Ex: "Commande créée", "Coupe terminée", "Essayage effectué"
  description     String?

  // Who did it
  userId          String?
  userName        String?

  // Photos (URLs from media upload)
  photos          String[] @default([])

  createdAt       DateTime @default(now())

  @@index([customOrderId])
  @@index([createdAt])
}

model CustomOrderAttachment {
  id              String   @id @default(cuid())
  customOrderId   String
  customOrder     CustomOrder @relation(fields: [customOrderId], references: [id], onDelete: Cascade)

  // File info
  filename        String
  originalName    String
  fileUrl         String
  fileType        String   // MIME type
  fileSize        Int      // Size in bytes
  category        String   @default("document") // document, image, audio, video, other

  // Description
  description     String?

  // Who uploaded
  uploadedById    String?
  uploadedByName  String?

  createdAt       DateTime @default(now())

  @@index([customOrderId])
  @@index([category])
}

// ========================================
// RECEIPTS (Reçus pour paiements)
// ========================================

model Receipt {
  id              String   @id @default(cuid())
  receiptNumber   String   @unique  // Format: REC-DDMMYY-0001

  // Liens vers les paiements
  customOrderPaymentId String?  @unique
  customOrderPayment   CustomOrderPayment? @relation(fields: [customOrderPaymentId], references: [id], onDelete: SetNull)
  invoicePaymentId     String?  @unique
  invoicePayment       InvoicePayment? @relation(fields: [invoicePaymentId], references: [id], onDelete: SetNull)

  // Info client
  customerName    String
  customerPhone   String?
  customerEmail   String?

  // Détails paiement
  amount          Float
  paymentMethod   String
  paymentDate     DateTime @default(now())

  // Références
  invoiceId       String?
  invoice         Invoice? @relation(fields: [invoiceId], references: [id], onDelete: SetNull)
  customOrderId   String?
  customOrder     CustomOrder? @relation(fields: [customOrderId], references: [id], onDelete: SetNull)

  // PDF stockage
  pdfUrl          String?
  pdfKey          String?

  // Audit
  createdById     String?
  createdByName   String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([receiptNumber])
  @@index([customOrderId])
  @@index([invoiceId])
  @@index([paymentDate])
  @@index([createdAt])
}

// ========================================
// EXPENSES MANAGEMENT (Gestion des Dépenses)
// ========================================

// Catégories de dépenses (flexible)
model ExpenseCategory {
  id          String    @id @default(cuid())
  name        String    @unique
  description String?
  icon        String?   // Nom de l'icône lucide (ex: "Zap" pour électricité)
  color       String?   // Couleur hex pour l'UI
  isDefault   Boolean   @default(false)
  sortOrder   Int       @default(0)
  expenses    Expense[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([sortOrder])
}

// Modes de paiement pour les dépenses
enum ExpensePaymentMethod {
  CASH           // Espèces
  BANK_TRANSFER  // Virement bancaire
  ORANGE_MONEY   // Orange Money
  MTN_MOMO       // MTN MoMo
  WAVE           // Wave
  CHECK          // Chèque
  CARD           // Carte bancaire
}

// Dépenses
model Expense {
  id              String               @id @default(cuid())

  // Catégorie
  categoryId      String
  category        ExpenseCategory      @relation(fields: [categoryId], references: [id])

  // Détails
  description     String
  amount          Float
  paymentMethod   ExpensePaymentMethod
  paymentDate     DateTime             @default(now())
  reference       String?              // N° facture/reçu externe

  // Lien optionnel avec un membre du staff (pour salaires)
  staffId         String?
  staff           User?                @relation("StaffExpenses", fields: [staffId], references: [id], onDelete: SetNull)

  // Pièces jointes (photo facture)
  attachmentUrl   String?

  // Notes
  notes           String?              @db.Text

  // Traçabilité
  createdById     String?
  createdBy       User?                @relation("ExpenseCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  createdByName   String?

  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt

  @@index([categoryId])
  @@index([staffId])
  @@index([paymentDate])
  @@index([createdById])
  @@index([createdAt])
}
